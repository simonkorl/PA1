# 编程报告

## 问题分析

>根据本题的提示“动态规划”，再结合题目要求尽可能减少修改的次数，可以猜测本题需要尽可能多地利用已有的字符串。
所以合理的猜想为本题可以使用最长公共子序列的算法，计算出两个字符串最长的公共子序列的长度，进行适当计算后得到最终结果。
>本题的困难之处在于数据规模很大。动态规划如果采用递归的方法进行计算，时间复杂度将为指数级别，不可能满足要求。并且使用二维数组的话，需要的空间过大。需要找到方法减少空间和时间的使用。

## 1.0 版本

>在参考了课本中求最长公共子序列的算法后，我先采用数组进行动态规划。在调试之后，程序可以正常运行并给出正确答案，但是在n和m增大后便超出了限定的内存大小。
>此方法时间复杂度和空间复杂度均为O(n*m)

## 1.1 版本

>为了解决1.0版本中出现的空间复杂度过大的问题，经过观察，我发现在动态规划的过程中每一次循环只需要知道上一次循环的结果。于是我仅使用了2*m大小的数组，分别记录上一次计算的结果和本轮计算的结果。在最后将两个数组的指针调换便可实现循环利用。
>虽然空间复杂度下降至O(m)，但是时间复杂度没有发生变化。导致程序在大数据点无法避免地出现超时的情况。

## 2.0 版本

>在上网搜寻了多种优化最长公共子序列的方法，但是基本上没有适合本题的优化时间复杂度的方法。于是我考虑放弃使用寻找最长公共子序列的方法，寻求其它的算法。
>在从同学处得到了一篇关于优化最短编辑距离的论文，经过学习后我将其中的伪代码部分实现，经过调试后成功通过了测试点。
>此方法中利用贪心算法和动态规划，将修改字符串转化为求有向图中的最短距离。图中的对角线代表了字符串中相同的字符，横向表示删除操作，纵向表示添加操作。算法中充分利用了对角线的特点，将时间复杂度降至O(n*k),空间复杂度为O(m+n)。
>但是由于本题的特点，最多只修改k次，所以可以将时间复杂度缩减至O(k^2),空间复杂度可下降为O(k),两者均大大减少。