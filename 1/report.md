# 编程报告

## 程序1.0版本

>1.0版本解决的主要问题包括：基础的大整数储存与相关操作，数据的读取和输出。
最终结果的计算与正常人类的竖式计算没有区别，时间复杂度为O(n*m^2)，其中n为总数据量，m为每一个数的位数。空间复杂度为O(m)

## 程序1.1版本

>1.1版本按照讨论出来的结果进行压位处理：讲整数按每四位进行储存。这样一是减少了储存空间，二是将计算时间压缩到1/4。
因为计算算法和进位算法没有任何改变，所以时间复杂度不变，只是时间与空间约缩小至之前的1/4.

## 程序1.1.1版本

>1.1版本没有完全将1.0版本的代码改成需要压位的版本，经过少量修改后，正确率下降至0

## 程序1.1.2版本

>1.1.1版本的问题导致我发现因为压位的关系，一个位中如果前面有0则无法显示。所以将情况一一枚举。

## 程序1.1.3版本

>1.1.2版本中虽然会在数字前面加0，但是会产生的问题是最高位不显示。解决了对应的bug,在90%数据中拿到65%

## 程序2.0 版本

>2.0版本将乘法计算的算法进行了调整。参考https://www.cnblogs.com/little-kwy/archive/2017/09/30/7613642.html上的数学公式，
将每一次的乘数进行二分，并且对两侧分别进行乘法运算。通过一定的数学方法，一次计算中，大整数的乘法运算为三。通过递归的方法，可以让时间复杂度下降为O(n*m^log2(3))。空间复杂度约为O(m)

## 程序2.5版本

>2.0版本中存在诸多错误，包括乘法计算中可能导致的无限循环。加减法运算错误等等。2.5版本将代码重构，加入了符号，使得大整数的
加法与减法能够以最简单的方法实现。

## 程序1.2版本

>从2.0的实现过程中想到，如果每一位可以计算的数字越多，那么总体的速度就会越快。于是将每一个储存位置改为储存8个数字，使用long long 
类型储存，并且实现乘法。但是因为没有改变过时间复杂度，所以速度反倒因为长整形的计算速度下降而变慢。

## 程序1.2.1版本

>1.2.1 版本的程序利用long 类型来储存每一位，每一位储存六个数字，但是速度几乎没有差异，相对而言更慢。

## 程序3.0.0版本

>在前面所有的尝试都失败后，我上网查询效率更高的高精度乘法算法。在很多资料中都提到了快速傅里叶变换，于是我上网查询了相关的介绍和程序实现。程序中的傅里叶变换实现算法参考了https://www.cnblogs.com/zwfymqz/p/8244902.html?mType=Group 中最后提供的代码。
利用快速傅里叶变换将程序的时间复杂度下降至O(n*log(n))。其中另一个优化算法为：利用下标二进制的性质，通过反转下标的二进制来做到快速分理出奇偶项可以将这一步的复杂度从O(n^2)下降至O(n)。整体程序的时间复杂度为T(n,m) = O(n * m *logm)，n为处理。空间复杂度为O(m)。

## 程序3.1.0版本

>3.0.0版本中因为对算法的不理解，导致最后的结果不正确。在进行过逆傅里叶变换后，需要对全部的数字位进行取整、转换和进位操作。之后才能得到最终结果。3.1.0版本使得程序可以给出正确结果。

## 程序3.1.2版本

>3.1.2版本处理了3.1.0版本中出现的内存访问错误

## 程序3.1.3版本

>3.1.3版本在3.1.2的基础上对整体进行了优化。减少了数组的重复分配，并且缩小了数组的大小保证内存不至于溢出。在调试之后成功通过90%的数据点